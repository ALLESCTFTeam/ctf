from pwn import *

# mov reg, value
def op_move_imm(dst, val):
    return p32((val << 16) | (dst << 5) | 0x2000 | 0x0)

# mov regA, regB
def op_move(dst, src):
    return p32((src << 16) | (dst << 5) | 0x0)

# add regA, value
def op_add_imm(dst, val):
    return p32((val << 16) | (dst << 5) | 0x2000 | 0x1)

# add regA, regB
def op_add(dst, src):
    return p32((src << 16) | (dst << 5) | 0x1)

# sub regA, value
def op_sub_imm(dst, val):
    return p32((val << 16) | (dst << 5) | 0x2000 | 0x2)

# sub regA, regB
def op_sub(dst, src):
    return p32((src << 16) | (dst << 5) | 0x2)
    
# xchg regA, regB
def op_xchg(dst, src):
    return p32((src << 9) | (dst << 5) | 0x3)
    
# xor regA, value
def op_xor_imm(dst, val):
    return p32((val << 16) | (dst << 5) | 0x2000 | 0x4)

# xor regA, regB
def op_xor(dst, src):
    return p32((src << 16) | (dst << 5) | 0x4)
    
# push value
def op_push_imm(val):
    return p32((val << 16) | 0x2000 | 0x5)

# push regA
def op_push(reg):
    return p32((reg << 5) | 0x5)
    
# pop regA
def op_pop(reg):
    return p32((reg << 5) | 0x6)

# Missing: Stack set relative (can be used to get RCE)
#          Stack get relative (can be used to leak pointers)
#          No bounds checking for both

# syscall number
def op_syscall(num):
    return op_move_imm(1, num) + p32(9)
    
# Show all registers + stack
def op_showregs():
    return p32(0xA)

# Reserve some space on the stack, syscall 3 (get flag), syscall 1 (print stack), reset stack
def get_flag():
    return op_sub_imm(14, 0xB) + op_syscall(3) + op_syscall(1) + op_add_imm(14, 0xB)

bytecode = [
    get_flag()
]

bytecode = "".join(bytecode)

r = remote("hfs-vm-01.play.midnightsunctf.se", 4096)
r.recvuntil("Input byte code length: ")
r.sendline(str(len(bytecode)))
r.recvuntil("Input byte code: ")
r.send(bytecode)
print r.recvall()
