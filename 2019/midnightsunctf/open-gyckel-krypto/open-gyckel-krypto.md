# Open Gyckel Krypto
- Tags: Crypto, DPA
- Points: 226
- Solves: 56

## Challenge
>Primes are fun, don't google translate me bro 

We get a textfile with python code:
```python
while True:
    p = next_prime(random.randint(0, 10**500))
    if len(str(p)) != 500:
        continue
    q = Integer(int(str(p)[250:] + str(p)[:250]))
    if q.is_prime():
        break

>> p * q
6146024643941503757217715363256725297474582575057128830681803952150464985329239705861504172069973746764596350359462277397739134788481500502387716062571912861345331755396960400668616401300689786263797654804338789112750913548642482662809784602704174564885963722422299918304645125966515910080631257020529794610856299507980828520629245187681653190311198219403188372517508164871722474627810848320169613689716990022730088459821267951447201867517626158744944551445617408339432658443496118067189012595726036261168251749186085493288311314941584653172141498507582033165337666796171940245572657593635107816849481870784366174740265906662098222589242955869775789843661127411493630943226776741646463845546396213149027737171200372484413863565567390083316799725434855960709541328144058411807356607316377373917707720258565704707770352508576366053160404360862976120784192082599228536166245480722359263166146184992593735550019325337524138545418186493193366973466749752806880403086988489013389009843734224502284325825989
>> pow(m, 65537, p * q)
3572030904528013180691184031825875018560018830056027446538585108046374607199842488138228426133620939067295245642162497675548656988031367698701161407333098336631469820625758165691216722102954230039803062571915807926805842311530808555825502457067483266045370081698397234434007948071948000301674260889742505705689105049976374758307610890478956315615270346544731420764623411884522772647227485422185741972880247913540403503772495257290866993158120540920089734332219140638231258380844037266185237491107152677366121632644100162619601924591268704611229987050199163281293994502948372872259033482851597923104208041748275169138684724529347356731689014177146308752441720676090362823472528200449780703866597108548404590800249980122989260948630061847682889941399385098680402067366390334436739269305750501804725143228482932118740926602413362231953728010397307348540059759689560081517028515279382023371274623802620886821099991568528927696544505357451279263250695311793770159474896431625763008081110926072287874375257
```

Google translation of the challenge title: `Open-fun-crypto`

## Solution
The script is easily identifiable as RSA, with a twist on the prime generation. To break it, we need to factor the modulus `n=p*q`.
Both p and q are 500 digits, thus n is 1000. This is far to long for normal factoring algorithms.
But notice that q is a 'swapped' version of p, ie we look at its representation in Base10 and swap the top and bottom half.

To solve the challenge we need to somehow represent this swapping as a mathematical operation. The easiest way to do this, is to define the bottom and top parts of p `a` and `b`. Doing this we can say
```
p = 10^250 * a + b
q = 10^250 * b + a
n = p*q = 10^500 * a*b + 10^250 * (a*a + b*b) + a * b
```
Now we have to pay close attention to the size of the sum terms:
```
a                      250 digits
b                      250 digits
a+b                    250 or 251 digits (overflow by 1)
a*b                    499 or 500 digits
10^500 * a*b:          499 or 500 digits, shifted by 500 0's
10^250 * (a*a + b*b)   499 to 501 digits, shifted by 250 0's
```
Thus the sum above can be seen as

|          n          |   top250 |  -------  |  -------   | bottom250|
|---------------------|:--------:|:---------:|:----------:|:--------:|
|    `10^500 *a*b`    | *A*      | *B*       | 0          | 0        |
| `10^250 *(a*a+b*b)` |   0 or 1 | *C*       | *D*        | 0        |
|       ` a*b `       |   0      |   0       | *A*        | *B*      |

Notice that we can calculate `a*b` by taking the top 250 and bottom 250 digits of n. We just have to be careful to check if `(a*a+b*b)` has overflowed, and thus adds 1 to the top part. Checking the two solutions, we see that for the given `n` it has indeed done so. Now knowing `a*b` we can also get `a*a+b*b` from `n` as:
```
a*a+b*b = 10^-250 * (n - a*b - 10^500*a*b)
```

This gives us a system of equations:
```
a*b = c1
a*a+b*b = c2
```

Anw while this can easily be transformed into a quadratic equation by hand, we are lazy and use z3. In python this looks like:
```python
from z3 import *
from Crypto.Util import number as num

e = 65537
n = 6146024643941503757217715363256725297474582575057128830681803952150464985329239705861504172069973746764596350359462277397739134788481500502387716062571912861345331755396960400668616401300689786263797654804338789112750913548642482662809784602704174564885963722422299918304645125966515910080631257020529794610856299507980828520629245187681653190311198219403188372517508164871722474627810848320169613689716990022730088459821267951447201867517626158744944551445617408339432658443496118067189012595726036261168251749186085493288311314941584653172141498507582033165337666796171940245572657593635107816849481870784366174740265906662098222589242955869775789843661127411493630943226776741646463845546396213149027737171200372484413863565567390083316799725434855960709541328144058411807356607316377373917707720258565704707770352508576366053160404360862976120784192082599228536166245480722359263166146184992593735550019325337524138545418186493193366973466749752806880403086988489013389009843734224502284325825989
c = 3572030904528013180691184031825875018560018830056027446538585108046374607199842488138228426133620939067295245642162497675548656988031367698701161407333098336631469820625758165691216722102954230039803062571915807926805842311530808555825502457067483266045370081698397234434007948071948000301674260889742505705689105049976374758307610890478956315615270346544731420764623411884522772647227485422185741972880247913540403503772495257290866993158120540920089734332219140638231258380844037266185237491107152677366121632644100162619601924591268704611229987050199163281293994502948372872259033482851597923104208041748275169138684724529347356731689014177146308752441720676090362823472528200449780703866597108548404590800249980122989260948630061847682889941399385098680402067366390334436739269305750501804725143228482932118740926602413362231953728010397307348540059759689560081517028515279382023371274623802620886821099991568528927696544505357451279263250695311793770159474896431625763008081110926072287874375257

n_str = str(n)
L = len(n_str) // 4

top    = int(n_str[:L]) - 1 # overflow!
bottom = int(n_str[-L:])

c1 = (10**L) * top + bottom
c2 = (n - c1 - c1 * 10**(2*L)) // 10**L

s = Solver()
a_ = Int('a')
b_ = Int('b')
s.add(c1 == a_ * b_)
s.add(c2 == a_**2 + b_**2)
s.add(a_>0) # we want positive solutions
s.add(b_>0)

assert s.check() == sat, 'No solution found'

# reconstruct p and q
a = s.model()[a_].as_long()
b = s.model()[b_].as_long()
p = 10**L*a + b
q = 10**L*b + a

assert n == p * q, 'Wrong solution found!'

# get plaintext
phi = (p-1)*(q-1)
d = num.inverse(e, phi)
m = pow(c, d, n)

print (num.long_to_bytes(m))
```

which gives us the flag as
```
midnight{w3ll_wh47_d0_y0u_kn0w_7h15_15_4c7u4lly_7h3_w0rld5_l0n6357_fl46_4nd_y0u_f0und_17_50_y0u_5h0uld_b3_pr0ud_0f_y0ur53lf_50_uhmm_60_pr1n7_7h15_0n_4_75h1r7_0r_50m37h1n6_4nd_4m4z3_7h3_p30pl3_4r0und_y0u}
```